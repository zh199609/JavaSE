类加载的过程：

​	加载》连接（验证、准备、解析）》初始化

类加载器：

​	虚拟机的设计团队吧类加载阶段中“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码模块称之为类加载器

​	只有被同一个类加载器加载的类才可能会相等，相同的字节码被不同的类加载器加载的类不相等。

启动类加载器（虚拟机的一部分，用于加载javahome下的lib）、扩展类加载器（记载javahome下lib/ext）、应用程序类加载器、自定义类加载器

验证：

​	确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

准备：

​	准备阶段正式为类变量分配内存并设置变量的初始值(默认值)，这些变量使用的内存都将在方法区中进行分配

​	class hello{	

​		static int a = 10;初始化为0 

​	}

解析

​	是虚拟机将常量池中的符号引用替换为直接引用的过程

初始化

​	初始化时类加载的最后一步，初始化是执行<clinit>方法的过程



初始化

​	遇到new、getstatic、putstatic、或invokestatic这四条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。java代码场景是：使用new关键字实例化对象，读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。

​	使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

​	当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化	

​	当虚拟机启动时，用户需指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类。

局部变量表

​	Slot(一般32位虚拟机32位)      Byte Boolean short char int float double long reference 

​	double long 需多个slot   出现线程安全性问题：多线程、共享资源，对共享资源非原子性操作



happens-before

​	用来指定两个操作之间的执行顺序，提供跨线程的内存可见性

​	程序顺序规则：当线程中每个操作，总是前一个操作happens-before后一个操作

​	监视器锁规则：对一个锁的解锁happens-before随后对这个锁的加锁

​	volatile规则：对一个volatil;e域的写，happens-before于任意后续这个volatile域的读

​	start规则、

​	join规则

重排序

​	数据依赖性

###### volatile和synchronize

​	线程安全的两个方面：执行控制和内存可见

​	**并发中需要解决的三个问题：可见性、原子性、有序性**

​	synchronize解决的是执行控制的问题，它还会创建一个内存屏障，内存屏障指令保证了所有cou操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得这个锁的线程的所有操作都happens-before于随后获得这个锁的线程的操作

​	volatile解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主内存，即保证了变量的可见性。

​	volatile本质是告诉jvm当前变量在寄存器中的值是不确定的，需要从主内存读取，synchronize则是锁定当前变量，只有当前线程能访问。volatile不能保证原子性

###### 支撑java内存模型的基础原理

​	指令重排序、数据依赖性、as-if-serial、内存屏障、happens-before