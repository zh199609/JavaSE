以前，在看很多博客的时候，总是有很多作者在描述ThreadLocal的作用是数据隔离，并且是每一个线程复制了一份，每个线程的访问的数据都是不受其他线程影响的。
其实，这句话前半句是对的，ThreadLocal的确是数据的隔离，但是并非数据的复制，而是在每一个线程中创建一个新的数据对象，然后每一个线程使用的是不一样的。

Map的key是ThreadLocal类的实例对象，value为用户的值，并不是网上大多数的例子key是线程的名字或者标识。


ThreadLocal是什么
ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，
各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。

ThreadLocalMap的问题
由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，
如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。
如何避免泄漏
既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。
如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。




产品需求已让我心力交瘁，无尽的bug已将我淹没，就算觉得自己一身清白，这一切都是产品经理的错，实在被冤死得委屈，也没人会懂我的心思 。
就算熬了无数个通宵，眼已熬得布满血丝无法聚焦，可是电脑里密密麻麻的代码，依然紧紧地拉扯着我，对我呼喊：欧巴，不要走~~我想，大概这就是爱吧！
这26个字母组成的美妙的单词，都是我人生不可或缺的钥匙！

















